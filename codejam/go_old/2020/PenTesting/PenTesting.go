package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)
var wrtr = bufio.NewWriterSize(os.Stdout, 10000000)
var rdr = bufio.NewScanner(os.Stdin)
func gs() string  { rdr.Scan(); return rdr.Text() }
func gi() int     { i,e := strconv.Atoi(gs()); if e != nil {panic(e)}; return i }
func gis(n int) []int  { res := make([]int,n); for i:=0;i<n;i++ { res[i] = gi() }; return res }
func ia(m int) []int { return make([]int,m) }
func iai(m int,v int) []int { a := make([]int,m); for i:=0;i<m;i++ { a[i] = v }; return a }
func twodi(n int,m int,v int) [][]int {
	r := make([][]int,n); for i:=0;i<n;i++ { x := make([]int,m); for j:=0;j<m;j++ { x[j] = v }; r[i] = x }; return r
}
func max(a,b int) int { if a > b { return a }; return b }
func min(a,b int) int { if a > b { return b }; return a }
func sumarr(a []int) int { ans := 0; for _,aa := range(a) { ans += aa }; return ans }
func vecintstring(a []int) string { astr := make([]string,len(a)); for i,a := range a { astr[i] = strconv.Itoa(a) }; return strings.Join(astr," ") }
type state struct { left, used, numleft int}
type res   struct { ev float64; move int}
func main() {
	//f1, _ := os.Create("cpu.prof"); pprof.StartCPUProfile(f1); defer pprof.StopCPUProfile()
	defer wrtr.Flush()
	infn := ""; if infn == "" && len(os.Args) > 1 {	infn = os.Args[1] }
	if infn != "" {	f, e := os.Open(infn); if e != nil { panic(e) }; rdr = bufio.NewScanner(f) }
	rdr.Split(bufio.ScanWords); rdr.Buffer(make([]byte,1024),1000000000)
	N := 15
	cache := make(map[state]res)
	var solvestate func(st state) res
	encodeState := func(used []int, left,numleft int) state {
		um := 0; uoffset := uint(0)
		for _,u := range used {
			if u == -1 { continue }
			um |= u << uoffset; uoffset += 4
		}
		return state{left,um,numleft}
	}
	solvestate = func(st state) res {
		v,ok := cache[st]
		if !ok {
			if st.numleft == 2 {
				t := 0; for i:=0;i<15;i++ { if st.left & (1 << uint(i)) != 0 { t += i } }
				t -= st.used & 0xf; t -= (st.used >> 4) & 0xf
				if t >= N { v = res{1.0,0} } else { v = res{0.0,0} }
			} else {
				// Option 1, eliminate the leftmost option
				encused := st.used >> 4
				ev1 := 0.00
				for i:=uint(0);i<15;i++ {
					if st.left & (1<<i) != 0 {
						r2 := solvestate(state{st.left ^ (1<<i),encused,st.numleft-1})
						ev1 += r2.ev
					}
				}
				ev1 *= 1.00 / float64(st.numleft)
				if ev1 > 1.01 { fmt.Fprintf(os.Stderr,"BAD EV1:%v\n",ev1); os.Exit(1) }
				// Option 2, eliminate the lowest number
				lowest := 0
				for st.left & (1 << uint(lowest)) == 0 { lowest++ }
				ev2 := 0.00
				encused2 := st.used >> 4
				for i:=0;i<st.numleft;i++ {
					if i > 0 { encused2 = encused2 & ^(0xf<<uint(4*i-4)) | ((lowest+1) << uint(4*i-4)) }
					r2 := solvestate(state{st.left ^ (1<<uint(lowest)),encused2,st.numleft-1})
					ev2 += r2.ev
				}
				ev2 *= 1.00 / float64(st.numleft)
				if ev2 > 1.01 { fmt.Fprintf(os.Stderr,"BAD EV2:%v\n",ev2); os.Exit(1) }
				if ev1 >= ev2 { v = res{ev1,1} } else { v = res{ev2,2} }
			}
			cache[st] = v
		} 
		return v
	}
	solvestate(state{1<<15-1,0,15})
	T := gi(); N = gi(); gi()
	used := twodi(T,N,0)
	leftarr := iai(T,1<<15 - 1)
	numleft := iai(T,15)
	retval := iai(T,0)
	scratch  := iai(T,0)
	move   := iai(T,-1)
	globstate := iai(T,0) // 0 is initial state, 1 is eliminating leftmost, 2 is eliminating lowest, and 3 is just waiting
	moves2 := ia(T)
	numrounds := N * (N+1) / 2
	for i:=0;i<=numrounds;i++ {
		// Generate the moves
		for idx:=0;idx<T;idx++ {
			if globstate[idx] == 1 {
				used[idx][move[idx]]++
				if retval[idx] == 0 { // We emptied the leftmost pen
					leftarr[idx] = leftarr[idx] ^ (1 << uint(used[idx][move[idx]]-1))
					used[idx][move[idx]] = -1
					numleft[idx]--
					globstate[idx] = 0
				}
			} else if globstate[idx] == 2 {
				used[idx][move[idx]]++
				if retval[idx] == 0 { // We found our weak pen
					leftarr[idx] = leftarr[idx] ^ (1 << uint(scratch[idx]))
					used[idx][move[idx]] = -1
					numleft[idx]--
					globstate[idx] = 0
				} else {
					for used[idx][move[idx]] < 0 || used[idx][move[idx]] == scratch[idx]+1 { move[idx]++ }
				}
			}
			if globstate[idx] == 0 {
				if numleft[idx] == 2 { 
					move[idx] = -1; globstate[idx] = 3
				} else {
					st := encodeState(used[idx],leftarr[idx],numleft[idx])
					res := solvestate(st)
					if res.move == 1 {
						globstate[idx] = 1
						l := 0; for used[idx][l] == -1 { l++ }
						move[idx] = l
					} else {
						globstate[idx] = 2
						l := 0; for leftarr[idx] & (1 << uint(l)) == 0 { l++ }
						scratch[idx] = l
						move[idx] = 0; for used[idx][move[idx]] < 0 { move[idx]++ }
					}
				}
			}
		}
		// Make the moves
		for i:=0;i<T;i++ { moves2[i] = move[i] + 1 }
		s := vecintstring(moves2)
		fmt.Fprintf(wrtr,"%v\n",s); wrtr.Flush()
		if sumarr(moves2) == 0 {
			final := make([]int,0)
			for i:=0;i<T;i++ {
				for j:=0;j<15;j++ {
					if used[i][j] != -1 { final = append(final,j+1) }
				}
			}
			s := vecintstring(final)
			fmt.Fprintf(wrtr,"%v\n",s); wrtr.Flush()
			break
		} else {
			for i:=0;i<T;i++ { retval[i] = gi() }
		}
	}
}
